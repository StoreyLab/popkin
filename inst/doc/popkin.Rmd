---
title: "Estimate Kinship and $F_{\\text{ST}}$ under Arbirary Population Structure with `popkin`"
author: "Alejandro Ochoa and John D. Storey"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: popkin.bib
vignette: >
  %\VignetteIndexEntry{Estimate Kinship and FST under Arbirary Population Structure}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

\newcommand{\Fst}{F_{\text{ST}}}
\newcommand{\ft}[1][j]{f_{#1}^T}
\newcommand{\kt}[1][k]{\varphi_{j#1}^T} % total kinship coefficient

# Introduction

The `popkin` ("population kinship") package lets users estimate the kinship matrix of all individuals in a dataset from their genotypes, which yields individual kinship and inbreeding coefficients as well as $\Fst$ for arbitrarily structured populations.
We recently introduced a new framework for generalizing and estimating $\Fst$ and kinship under arbitrary population structures [@Ochoa083915; @Ochoa083923].
Here we briefly summarize the notation and intuition behind the key parameters.

## Kinship and inbreeding coefficients

Let $T$ be the reference ancestral population, which sets the level of relatedness treated as zero as explained shortly.
$\ft$ is the inbreeding coefficient of individual $j$ when $T$ is the ancestral population, and
$\kt$ is the kinship coefficient of the pair individuals $j,k$ when $T$ is the ancestral population.
Both $\ft,\kt$ are probabilities of "identity by descent" (IBD) that are more carefully defined elsewhere [@Ochoa083915; @Ochoa083923].
In a structured population we expect most if not all $\ft,\kt >0$.
If $j,k$ are the parents of $l$ then $\ft[l] = \kt$, so within a panmictic subpopulation we expect $\ft \approx \kt$ for $j \ne k$.
The kinship definition also applies to $j=k$ (the "self-kinship"), which counterintuitively equals $\kt[j] = \frac{1}{2}\left( 1+\ft \right)$ rather than $\ft$.

Let $\Phi^T = (\kt)$ be the $n \times n$ matrix that contains all kinship coefficients of all individuals in a dataset.
The ancestral population $T$ is the most recent common ancestor (MRCA) population if and only if $\min \kt = 0$, assuming such unrelated pairs of individuals exist in the dataset.
Thus, the only role $T$ plays in our estimates is determining the level of relatedness that is treated as zero.

Note that the diagonal of our estimated $\Phi^T$ contains $\kt[j]$ values rather than $\ft$, which must be so for statistical modeling applications; however, for visualization purposes $\kt[j]$ tends to take on much greater values than $\kt$ for $j \ne k$, while $\ft \approx \kt$ for $j \ne k$ within panmictic subpopulations (see above), so replacing the diagonal of $\Phi^T$ with $\ft$ values results in more aesthetically-pleasing figures.

## The Generalized $\Fst$

$\Fst$ is also an IBD probability that equals the mean inbreeding coefficients in a population partitioned into homogeneous subpopulations.
We recently introduced a generalized $\Fst$ definition that applies to arbitrary population structures---droping the need for subpopulations--and partitions "total" inbreeding into "local" inbreeding (due to having unusually closely related parents) and "structural" inbreeding (due to the population structure) [@Ochoa083915].
Future work will focus on extracting structural from total kinship, but in the meantime only the total kinship matrix $\Phi^T$ is estimated by `popkin`.
However, when all individuals are "locally outbred"---the most common case in population data---$\Fst$ is simply the weighted mean inbreeding coefficient:
$$
\Fst = \sum_{j=1}^n w_j \ft,
$$
where $0<w_j<1,\sum_{j=1}^n w_j =1$ are weights for individuals intended to help users balance skewed samples (i.e. if there are subpopulations with much greater sample sizes than othes).
The `popkin` package assumes all individuals are locally outbred in estimating $\Fst$.

# Sample usage

## Loading data

The `popkin` package does not come with its own data parsers, but accepts inputs in three forms.

1.  The simplest case assumes your genotypes are in an R matrix `X` that contains values only in `c(0L,1L,2L,NA)` (recall in R `0` is internally as double but `0L` is an integer; `popkin` handles both but providing only integers will be most efficient).
This is a standard encoding for biallelic SNPs that counts reference alleles: 2 is homozygous for the reference allele, 0 is homozygous for the alternative allele, 1 is heterozygous, and NA is missing data.
Which allele is the reference does not matter, `popkin` gives the same kinship and $\Fst$ estimates if you input `X` or `2L-X`.
By default `popkin` expects loci along rows and individuals along columns (an $m \times n$ matrix); you may input a transposed `X` matrix to the `popkin` function along with `lociOnCols=TRUE`.

1.  If your data is in BED format, we recommend using the `BEDMatrix` package to load this data.
For example, if you have the three files `myData.bed`, `myData.bim`, `myData.fam`, you can load the BEDMatrix object using:
```r
library(BEDMatrix)
X <- BEDMatrix('myData') # note: excluding extension is ok
```
Note this `X` is not exactly like the regular matrix `X` in the first case because the data is not loaded onto memory until you access it, but `popkin` accepts either as input and just works.
`popkin` is designed to work with `BEDMatrix` to use memory as efficiently as possible.
The [plink2](https://www.cog-genomics.org/plink2) software can be used to convert many common formats into BED.

1.  The last option is to provide a function `X(m)` that when called loads the next $m$ SNPs of the data, returning an $m \times n$ matrix in the same format as `X` in the first case above.
This option is provided for non-BED data that is too large to load into an R matrix.
Since this requires the most work from users (who must write their own functions `X(m)` for their custom formats), we recommend converting the data into BED format and using `BEDMatrix` to load it.


## Load and clean sample data

For illustration, let's load the real human data worldwide sample ("HGDP subset") contained in the `lfa` package:

```{r}
library(popkin)
library(lfa) # for hgdp_subset sample data only
X <- hgdp_subset # rename for simplicity
dim(X)
```

Therefore, this data has $m=`r nrow(X)`$ loci and $n=`r ncol(X)`$ individuals, and is oriented as `popkin` expects by default.
These samples have labels grouping them by continental subpopulation in `colnames(X)`.
To make visualizations easier later on, let's shorten these labels and reorder to have nice blocks:

```{r}
# shorten subpopulation labels
colnames(X)[colnames(X)=='AFRICA'] <- 'AFR'
colnames(X)[colnames(X)=='MIDDLE_EAST'] <- 'MDE'
colnames(X)[colnames(X)=='EUROPE'] <- 'EUR'
colnames(X)[colnames(X)=='CENTRAL_SOUTH_ASIA'] <- 'SAS'
colnames(X)[colnames(X)=='EAST_ASIA'] <- 'EAS'
colnames(X)[colnames(X)=='OCEANIA'] <- 'OCE'
colnames(X)[colnames(X)=='AMERICA'] <- 'AMR'
# order roughly by distance from Africa
popOrder <- c('AFR', 'MDE', 'EUR', 'SAS', 'EAS', 'OCE', 'AMR')
# applies reordering
X <- X[,order(match(colnames(X), popOrder))]
subpops <- colnames(X) # extract subpopulations vector
```

Now we're ready to analyze this data with `popkin`!

## Estimate the kinship matrix and $\Fst$ using subpopulations

Estimating a kinship matrix requires the genotype matrix `X` and subpopulation levels used only to estimate the minimum level of kinship.
Given the previous data, obtaining the estimate is simple:
```{r}
Phi <- popkin(X, subpops)
```

Let's visualize the data.  First let's setup a simple heatmap function:
```{r, fig.width=6, fig.height=6, fig.align='center'}
# quick and dirty heatmap of the kinship matrix
library(RColorBrewer)
myHeatmap <- function(Phi, subpops=NULL) {
    # place subpop labels in middle of their ranges
    subpopLabs <- NULL
    if (!is.null(subpops)) {
       	subpopLabs <- aggregate(1:length(subpops), list(subpop=subpops), mean) # mean index per subpop
    }
    colHM <- brewer.pal(9, 'Reds') # heatmap colors
    par(xaxt='n', yaxt='n') # heatmap doesn't omit axes correctly, force here
    # plot as image, without reordering, dendrograms, etc
    heatmap(Phi, Rowv=NA, Colv=NA, symm=TRUE, col=colHM, xlab='individuals', ylab='individuals',
    add.expr={
        # add population labels
	if (!is.null(subpopLabs)) {
	    mtext(subpopLabs$subpop, 1, at=subpopLabs$x, line=1, cex=0.7)
	    mtext(subpopLabs$subpop, 4, at=subpopLabs$x, line=1, cex=0.7)
	}
    })
    par(xaxt='s', yaxt='s') # reset to other plots aren't affected
    
}

# make plot
myHeatmap(Phi, subpops)
```

In the previous plot it's clear that the self-kinship estimates (the diagonal) are much greater than the rest of the kinship values (the minimum along the diagonal is 0.5).
It makes more sense to plot the inbreeding coefficients along the diagonal, so `popkin` includes the `inbrDiag` function that rescales the diagonal appropriately:

```{r, fig.width=6, fig.height=6, fig.align='center'}
myHeatmap(inbrDiag(Phi), subpops)
```

This figure clearly shows the population structure of these worldwide samples, with block patterns that are coherent with serial founder effects in the dispersal of humans out of Africa.
Since only $m=5000$ SNPs are included in this sample, the estimates are somewhat noisier than they would be in full data (datasets routinely have over 300 thousand SNPs).

This figure also illustrates how subpopulations are used to estimate kinship by `popkin`: they are only set to set the zero kinship as the mean kinship between the two most distant populations, which in this case are AFR and AMR.

$\Fst$ is then estimated from the kinship matrix.
Since $\Fst$ is the weighted mean of the inbreeding coefficients, and since some subpopulations are overrepresented in this data (EAS is much larger than the rest), it makes sense to use weights that balance these subpopulations:
```{r}
# get weights
w <- weightsSubpops(subpops)
# compute FST!
# Note: don't use the output to inbrDiag(Phi) or FST will be wrong!
fst(Phi, w)
```

If you compare these estimates to those we obtained for Human Origins [@Ochoa083915], you'll notice things look a bit different: $\Fst$ is smaller and the kinship within AFR is relatively much higher than within EUR or EAS.
Besides containing many fewer SNPs, this HGDP sample is older and likely suffered from SNP ascertainment issues, which might explain the difference.

***Missing: demonstration for `inbr` function!***

## Rescale kinship matrix in a subset of the data

Suppose now you're interested in one subpopulation, say AFR.
Removing other populations changes the MRCA population $T$, so the appropriate action is to re-estimate the kinship matrix in this subset only, although this could be slow if you have a very large dataset.
Fortunately, you can take the kinship matrix you already had and manipulate it to get the same answer!

```{r, fig.width=6, fig.height=6, fig.align='center'}
# filter to only keep individuals within AFR
indexesAfr <- subpops == 'AFR'
PhiAfr <- Phi[indexesAfr,indexesAfr]

# estimate FST before rescaling (this value will be wrong, too high!)
fst(PhiAfr)

# now rescale
# since subpops is missing, minimum Phi value is set to zero
# (no averaging between subpopulations)
PhiAfr <- rescalePopkin(PhiAfr)
# FST is now correct, relative to the MRCA of AFR individuals
fst(PhiAfr)
# kinship matrix visualization
myHeatmap(inbrDiag(PhiAfr))
```


# References