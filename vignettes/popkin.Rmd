---
title: "Estimate Kinship and $F_{\\text{ST}}$ under Arbitrary Population Structure with `popkin`"
author: "Alejandro Ochoa and John D. Storey"
date: "`r Sys.Date()`"
output:
  - pdf_document
#  - rmarkdown::html_vignette
bibliography: popkin.bib
vignette: >
  %\VignetteIndexEntry{Estimate Kinship and FST under Arbitrary Population Structure}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

\newcommand{\Fst}{F_{\text{ST}}}
\newcommand{\ft}[1][j]{f_{#1}^T}
\newcommand{\kt}[1][k]{\varphi_{j#1}^T} % total kinship coefficient

# Introduction

The `popkin` ("population kinship") package lets users estimate the kinship matrix of all individuals in a dataset from their genotypes, which yields individual kinship and inbreeding coefficients as well as $\Fst$ for arbitrarily structured populations.
We recently introduced a new framework for generalizing and estimating $\Fst$ and kinship under arbitrary population structures [@Ochoa083915; @Ochoa083923].
Here we briefly summarize the notation and intuition behind the key parameters.

## Kinship and inbreeding coefficients

Let $T$ be the reference ancestral population, which sets the level of relatedness treated as zero as explained shortly.
$\ft$ is the inbreeding coefficient of individual $j$ when $T$ is the ancestral population, and
$\kt$ is the kinship coefficient of the pair individuals $j,k$ when $T$ is the ancestral population.
Both $\ft,\kt$ are probabilities of "identity by descent" (IBD) that are more carefully defined elsewhere [@Ochoa083915; @Ochoa083923].
In a structured population we expect most if not all $\ft,\kt >0$.
If $j,k$ are the parents of $l$ then $\ft[l] = \kt$, so within a panmictic subpopulation we expect $\ft \approx \kt$ for $j \ne k$.
The kinship definition also applies to $j=k$ (the "self-kinship"), which counterintuitively equals $\kt[j] = \frac{1}{2}\left( 1+\ft \right)$ rather than $\ft$.

Let $\Phi^T = (\kt)$ be the $n \times n$ matrix that contains all kinship coefficients of all individuals in a dataset.
The ancestral population $T$ is the most recent common ancestor (MRCA) population if and only if $\min \kt = 0$, assuming such unrelated pairs of individuals exist in the dataset.
Thus, the only role $T$ plays in our estimates is determining the level of relatedness that is treated as zero.

Note that the diagonal of our estimated $\Phi^T$ contains $\kt[j]$ values rather than $\ft$, which is required for statistical modeling applications; however, $\kt[j]$ tends to take on much greater values than $\kt$ for $j \ne k$, while $\ft \approx \kt$ for $j \ne k$ within panmictic subpopulations (see above), so for visualization we strongly recommend replacing the diagonal of $\Phi^T$ with $\ft$ values.

## The generalized $\Fst$

$\Fst$ is also an IBD probability that equals the mean inbreeding coefficients in a population partitioned into homogeneous subpopulations.
We recently generalized the $\Fst$ definition to arbitrary population structures---dropping the need for subpopulations---and generalized the partition of "total" inbreeding into "local" inbreeding (due to having unusually closely related parents) and "structural" inbreeding (due to the population structure) [@Ochoa083915].
The current `popkin` estimates the total kinship matrix $\Phi^T$ only; in the future, `popkin` will also extract the structural kinship matrix.
However, when all individuals are "locally outbred"---the most common case in population data---$\Fst$ is simply the weighted mean inbreeding coefficient:
$$
\Fst = \sum_{j=1}^n w_j \ft,
$$
where $0<w_j<1,\sum_{j=1}^n w_j =1$ are weights for individuals intended to help users balance skewed samples (i.e. if there are subpopulations with much greater sample sizes than others).
The current `popkin` version assumes all individuals are locally outbred in estimating $\Fst$.

## The individual-level pairwise $\Fst$

Another quantity of interest is the individual-level pairwise $\Fst$, which generalize the $\Fst$ between two populations to pairs of individuals.
Here each comparison between two individuals has a different ancestral population, namely the MRCA population of the two individuals.
When individuals are again locally outbred and also locally unrelated, the pairwise $\Fst$ is given in terms of the inbreeding and kinship coefficients [@Ochoa083915]:
$$
F_{jk} = \frac{\frac{\ft+\ft[k]}{2}-\kt}{1-\kt}.
$$
The `popkin` package also provides an estimator of the pairwise $\Fst$ matrix (containing $F_{jk}$ estimates between every pair of individuals).

# Sample usage

## Loading data

The `popkin` function accepts biallelic genotype matrices in three forms:

1.  A genotype matrix `X` with values in `c(0L,1L,2L,NA)` only (in R `0` is internally as double but `0L` is an integer; `popkin` handles both but providing only integers is best).
This standard encoding for biallelic SNPs counts reference alleles: 2 is homozygous for the reference allele, 0 is homozygous for the alternative allele, 1 is heterozygous, and NA is missing data.
Which allele is the reference does not matter: `popkin` estimates the same kinship and $\Fst$ for `X` and `2L-X`.
By default `popkin` expects loci along rows and individuals along columns (an $m \times n$ matrix); a transposed `X` is handled best by also setting `lociOnCols=TRUE`.

1.  BED-formatted data loaded with the `BEDMatrix` package, which `popkin` uses to keep memory usage low.
For example, load `myData.bed`, `myData.bim`, `myData.fam` using:
```r
library(BEDMatrix)
X <- BEDMatrix('myData') # note: excluding extension is ok
```
This `BEDMatrix` object is not a regular matrix but `popkin` handles it correctly.
Other genotype formats can be converted into BED using [plink2](https://www.cog-genomics.org/plink2) or other software.

1.  A function `X(m)` that when called loads the next $m$ SNPs of the data, returning an $m \times n$ matrix in the format of Case 1 above.
This option allows direct and memory-efficient processing of large non-BED data, but should be the last resort since users must write their own functions `X(m)` for their custom formats.
Try first converting your data to BED and loading with `BEDMatrix`.


## Load and clean sample data

For illustration, let's load the real human data worldwide sample ("HGDP subset") contained in the `lfa` package:

```{r}
library(popkin)
library(lfa) # for hgdp_subset sample data only
X <- hgdp_subset # rename for simplicity
dim(X)
```

This data has $m=`r nrow(X)`$ loci and $n=`r ncol(X)`$ individuals, and is oriented as `popkin` expects by default.
These samples have labels grouping them by continental subpopulation in `colnames(X)`.
To make visualizations easier later on, let's shorten these labels and reorder to have nice blocks:

```{r}
# shorten subpopulation labels
colnames(X)[colnames(X)=='AFRICA'] <- 'AFR'
colnames(X)[colnames(X)=='MIDDLE_EAST'] <- 'MDE'
colnames(X)[colnames(X)=='EUROPE'] <- 'EUR'
colnames(X)[colnames(X)=='CENTRAL_SOUTH_ASIA'] <- 'SAS'
colnames(X)[colnames(X)=='EAST_ASIA'] <- 'EAS'
colnames(X)[colnames(X)=='OCEANIA'] <- 'OCE'
colnames(X)[colnames(X)=='AMERICA'] <- 'AMR'
# order roughly by distance from Africa
popOrder <- c('AFR', 'MDE', 'EUR', 'SAS', 'EAS', 'OCE', 'AMR')
# applies reordering
X <- X[,order(match(colnames(X), popOrder))]
subpops <- colnames(X) # extract subpopulations vector
```

Now we're ready to analyze this data with `popkin`!

## Estimate the kinship matrix and $\Fst$ using subpopulations

Estimating a kinship matrix requires the genotype matrix `X` and subpopulation levels used only to estimate the minimum level of kinship.
Given the previous data, obtaining the estimate is simple:
```{r}
Phi <- popkin(X, subpops)
```

Now let's visualize the raw kinship matrix estimate:

```{r, fig.width=6, fig.height=5, fig.align='center'}
# set outer margin for axis labels (left and right are non-zero)
par(oma=c(0,1.5,0,3))
# set inner margin for subpopulation labels (bottom and left are non-zero), add padding
par(mar=c(1,1,0,0)+0.2)
# now plot!
plotPopkin(Phi, labs=subpops)
```

The previous plot shows that the self-kinship estimates (the diagonal) are much greater than the rest of the kinship values (the minimum along the diagonal is 0.5).
As explained in the introduction, it makes more sense to plot inbreeding coefficients on the diagonal, which is achieved using `inbrDiag`:

```{r, fig.width=6, fig.height=5, fig.align='center'}
par(oma=c(0,1.5,0,3))
par(mar=c(1,1,0,0)+0.2)
plotPopkin(inbrDiag(Phi), labs=subpops)
```

Lastly, let's improve the labeling by setting `labsEven=TRUE`, which arranges the subpopulation labels with equal spacing and adds lines that map to their blocks.
To see these new lines, we must move these labels further from the heatmap by setting `labsLine=1`:

```{r, fig.width=6, fig.height=5, fig.align='center'}
par(oma=c(0,1.5,0,3))
# increase margins because labels go farther out
par(mar=c(2,2,0,0)+0.2)
plotPopkin(inbrDiag(Phi), labs=subpops, labsEven=TRUE, labsLine=1)
```

This figure clearly shows the population structure of these worldwide samples, with block patterns that are coherent with serial founder effects in the dispersal of humans out of Africa.
Since only $m=5000$ SNPs are included in this sample, the estimates are noisier than in more complete data (datasets routinely have over 300K SNPs).

This figure also illustrates how subpopulations are used to estimate kinship by `popkin`: they only set the zero kinship as the mean kinship between the two most distant populations, which in this case are AFR and AMR.

$\Fst$ is then estimated from the kinship matrix.
Since $\Fst$ is the weighted mean of the inbreeding coefficients, and since some subpopulations are overrepresented in this data (EAS is much larger than the rest), it makes sense to use weights that balance these subpopulations:
```{r}
# get weights
w <- weightsSubpops(subpops)
# compute FST!
# Note: don't use the output to inbrDiag(Phi) or FST will be wrong!
fst(Phi, w)
```

If you compare these estimates to those we obtained for Human Origins [@Ochoa083915], you'll notice things look a bit different: here $\Fst$ is smaller and the kinship within AFR is relatively much higher than within EUR or EAS.
Besides containing many fewer SNPs, this HGDP sample is older and likely suffered from SNP ascertainment issues, which might explain the difference.

We calculate individual-level pairwise $\Fst$ estimates from the previous kinship estimates using `pwfst`.
Note that the pairwise $\Fst$ is a distance between pairs of individuals: approximately zero for individuals in the same population, and increasing for more distant pairs of individuals.

```{r, fig.width=6, fig.height=5, fig.align='center'}
pwF <- pwfst(Phi) # compute pairwise FST matrix from kinship matrix
legTitle <- expression(bold(paste('Pairwise ', F[ST]))) # fancy legend label
par(oma=c(0,1.5,0,3))
par(mar=c(2,2,0,0)+0.2)
# NOTE no need for inbrDiag() here!
plotPopkin(pwF, labs=subpops, labsEven=TRUE, labsLine=1, legTitle=legTitle)
```

Lastly, we can extract the vector of inbreeding coefficients from the kinship matrix using `inbr`:

```{r, fig.width=4, fig.height=2, fig.align='center'}
inbrs <- inbr(Phi) # vector of inbreeding coefficients
par(mar=c(4, 4, 0, 0) + 0.1) # reduce margins
plot(density(inbrs), xlab='inbreeding coefficient', main='') # see their distribution
```

## Rescale kinship matrix in a subset of the data

Suppose now you're interested in one subpopulation, say AFR.
Removing other populations changes the MRCA population $T$, so the appropriate action is to re-estimate the kinship matrix in this subset only, although this could be slow if you have a very large dataset.
Fortunately, you can take the kinship matrix you already had and manipulate it to get the same answer!

```{r, fig.width=3, fig.height=2, fig.align='center'}
# filter to only keep individuals within AFR
indexesAfr <- subpops == 'AFR'
PhiAfr <- Phi[indexesAfr,indexesAfr]

# estimate FST before rescaling (this value will be wrong, too high!)
fst(PhiAfr)

# now rescale
# since subpops is missing, minimum Phi value is set to zero
# (no averaging between subpopulations)
PhiAfr <- rescalePopkin(PhiAfr)
# FST is now correct, relative to the MRCA of AFR individuals
fst(PhiAfr)
# kinship matrix visualization
par(oma=c(0,1.5,0,3))
# use zero margins because there are no subpopulation labels
par(mar=c(0,0,0,0)+0.2)
plotPopkin(inbrDiag(PhiAfr))
```

In this sample dataset there are no labels for individuals or sub-subpopulations, so we can't interpret this matrix further, beyond that there is clear substructure within Sub-Saharan Africa.

## Plot multiple kinship matrices together

As a final example, we plot the global `Phi` and the rescaled AFR subset `PhiAfr` side-by-side, illustrating how more than one kinship matrix can be plotted with a shared legend.

```{r, fig.width=6, fig.height=2.5, fig.align='center'}
par(oma=c(0,1.5,0,3))
par(mar=c(2,2,0,0)+0.2)
# transform both matrices and store in a list
x <- list(inbrDiag(Phi), inbrDiag(PhiAfr))
# dummy labels to have lines in second panel
subpopsAfr <- subpops[indexesAfr]
# pass labels that differ per panel using a list
labs <- list(subpops, subpopsAfr)
# labsEven and labsLine passed as scalars are shared across panels
# labsCex reduces the label size, since there's less space here!
plotPopkin(x, labs=labs, labsEven=TRUE, labsLine=1, labsCex=0.5)
```

# References